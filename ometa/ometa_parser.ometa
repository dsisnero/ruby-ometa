
ometa OMetaParser <: OMeta {
  nameFirst      = <_$.^> | letter
,
  nameRest       = nameFirst | digit
,
  tsName         = firstAndRest("nameFirst","nameRest"):xs        ->  leterize(xs.join('')) 
,
  name           = spaces tsName
,
  eChar          = '\\' char:c                                         ->  unescapeChar c 
                 | char
,
  tsString       = '\'' (~'\'' eChar)*:xs '\''                         ->  xs.join('') 
,
  characters     = '\'' '\'' (~('\'' '\'') eChar)*:xs '\'' '\''          ->  ['App', 'seq',     xs.join('').inspect] 
,
  sCharacters    = '"'     (~'"'         eChar)*:xs '"'                ->  ['App', 'token',   xs.join('').inspect] 
,
  string         = ('#' tsName | tsString):xs                  ->  ['App', 'exactly', xs.inspect] 
,
  number         = ('-' | empty -> { '' }):sign digit+:ds              ->  ['App', 'exactly', sign + ds.join('')] 
,
  keyword :xs    = token(xs) ~letterOrDigit                          ->  xs 
,
  hostExpr       = BSRubyParser::expr:r                    BSRubyTranslator::trans(r)
,
  atomicHostExpr = BSRubyParser::semAction:r               BSRubyTranslator::trans(r)
,
  inlineHostExpr = BSRubyParser::semAction2:r              BSRubyTranslator::trans(r)
,
  args           = ~space hostExpr:xs              ->  xs 
                 | empty                                               ->  "" 
,
  application    = 	name:klas "::" name:rule args:as	 								 ->  ['App', 'foreign',klas,rule.inspect, *as] 
									|	name:rule args:as                                  ->  ['App', rule, *as] 
,
	or = "|"
,
  expr           = listOf("expr4", "or"):xs                         ->  (xs.size==1 ? xs[0] : ['Or',        *xs] )
,
  expr4          = expr3*:xs                                           -> (xs.size==1 ? xs[0] : ['And',       *xs] )
,
  optIter :x     = "*"                                                 ->  ['Many',        x]
                 | "+"                                                 ->  ['Many1',       x] 
                 | "?" ~inlineHostExpr																 ->  ['Or', x,['App','empty']] 
								 | empty                                               ->  x 
,
	binding :x     = ':' name:n  ( '[' ']'  ->  @arrays << n; ['Append', n, x] 
															 | empty    ->  @locals << n; ['Set', n, x]
															 )
,
  expr3          = expr2:x optIter(x):x (binding(x) |empty ->{x}) 
									 | spaces ->{ x=['App','anything']}  binding(x)
,
  expr2          = "~" expr2:x                                         ->  ['Not',         x] 
                 | "&" ~inlineHostExpr expr1:x                         ->  ['Lookahead',   x] 
                 | expr1
,
  expr1          = application
								 | "@" name:var "=>" application:x									 ->  ['Key',  var,   x]
                 | "->" atomicHostExpr:x                       ->  ['Act',         x]
								 | "&"  inlineHostExpr:x                       ->  ['Pred',        x]
								 | spaces (characters | sCharacters | string | number)
                 | "[" expr:x "]"                                      ->  ['Form', x] 
                 | "<" (~">" eChar)+:x  ">"                            ->  ['App', 'regch', x.join('').inspect] 
                 | "(" expr:x ")"                                      ->  x 
,
  ruleName       = name
                 | spaces tsString
,
  rule           = &(ruleName:n) -> @locals = []; @arrays = []
                     rulePart(n):x (ruleSep rulePart(n))*:xs           ->  ['Rule', n, @locals,@arrays, ['Or', x, *xs]] 
,
  rulePart :rn   = ruleName:n &{n == rn} expr4:b1 ( "=" expr:b2        ->  ['And', b1, b2] 
                                                  | empty              ->  b1 
                                                  )
,
  grammar        = keyword("ometa") name:n
                   ( "<:" name | empty -> { 'OMeta' }):sn
                   "{" listOf("rule", "ruleSep"):rs "}"                  ->  ['Grammar', n, sn, *rs]
,
	ruleSep = ","
}
